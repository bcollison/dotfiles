#+TITLE: Emacs Configuration
#+AUTHOR: Brian Collison
#+EMAIL: brian@briancollison.com
#+OPTIONS: toc:nil num:nil

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes the
initial setup for =package.el= and ensures that =use-package= is installed, since I
wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+end_src

Disable TLS 1.3; ELPA has higher standards. That'll be the default in Emacs
26.3, I think, but I'm not there yet.

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* Use =sensible-defaults.el=

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
  (load-file "~/Personal/projects/sensible-defaults.el/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

* Set personal information

** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Brian Collison"
        user-mail-address "brian@briancollison.com"
        calendar-latitude 33.1581
        calendar-longitude -117.3506
        calendar-location-name "Carlsbad, CA")
#+END_SRC

** Access my netrc data

I store a few credentials in a =.netrc= file. Actually, I think the only creds I
have in there right now are for Instapaper, but this is still a convenient way
to store not-too-terribly-sensitive secrets.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)

  (setq netrc-file "~/.netrc")

  (defun netrc-username (machine)
    "Helper function to extract a username from my netrc."
    (car (netrc-credentials machine)))

  (defun netrc-password (machine)
    "Helper function to extract a password from my netrc."
    (cadr (netrc-credentials machine)))
#+END_SRC

* Add =resources= to =load-path=

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun hrs/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
              (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
         name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/visit-last-migration ()
    "Open the most recent Rails migration. Relies on projectile."
    (interactive)
    (let ((migrations
           (directory-files
            (expand-file-name "db/migrate" (projectile-project-root)) t)))
      (find-file (car (last migrations)))))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun hrs/insert-password ()
    (interactive)
    (shell-command "pwgen 30 -1" t))

  (defun hrs/notify-send (title message)
    "Display a desktop notification by shelling out to `notify-send'."
    (call-process-shell-command
     (format "notify-send -t 2000 \"%s\" \"%s\"" title message)))
#+end_src

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Load up a theme

I'm currently trying out the "modus-operandi" theme. I've got a scenic
wallpaper, so just a hint of transparency looks lovely and isn't distracting or
hard to read.

#+begin_src emacs-lisp
  (use-package modus-operandi-theme)

  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (defun hrs/apply-theme ()
    "Apply my chosen theme and make frames just slightly transparent."
    (interactive)
    (load-theme 'modus-operandi t)
    (transparency 100))
#+end_src

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+begin_src emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (hrs/apply-theme))))
    (hrs/apply-theme))
#+end_src

** Use =minions= to hide all minor modes (Disabled until I understand)

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+begin_src emacs-lisp
;;   (use-package minions
;;     :config
;;     (setq minions-mode-line-lighter ""
;;           minions-mode-line-delimiters '("" . ""))
;;     (minions-mode 1))
#+end_src

** Disable visual bell (Disabled)

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
;;  (setq ring-bell-function 'ignore)
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src

** Set default font and configure font resizing

I'm partial to Inconsolata for code and Libre Baskerville for prose.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
  (setq hrs/default-fixed-font "Inconsolata")
  (setq hrs/default-fixed-font-size 140)
  (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
  (set-face-attribute 'default nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)
  (set-face-attribute 'fixed-pitch nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)

  (setq hrs/default-variable-font "Libre Baskerville")
  (setq hrs/default-variable-font-size 120)
  (setq hrs/current-variable-font-size hrs/default-variable-font-size)
  (set-face-attribute 'variable-pitch nil
                      :family hrs/default-variable-font
                      :height hrs/current-variable-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/set-font-size ()
    "Change default, fixed-pitch, and variable-pitch font sizes to match respective variables."
    (set-face-attribute 'default nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'fixed-pitch nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'variable-pitch nil
                        :height hrs/current-variable-font-size))

  (defun hrs/reset-font-size ()
    "Revert font sizes back to defaults."
    (interactive)
    (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
    (setq hrs/current-variable-font-size hrs/default-variable-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font sizes by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-fixed-font-size
          (ceiling (* hrs/current-fixed-font-size hrs/font-change-increment)))
    (setq hrs/current-variable-font-size
          (ceiling (* hrs/current-variable-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font sizes by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-fixed-font-size
          (max 1
               (floor (/ hrs/current-fixed-font-size hrs/font-change-increment))))
    (setq hrs/current-variable-font-size
          (max 1
               (floor (/ hrs/current-variable-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Highlight uncommitted changes (Disabled)

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
;;  (use-package diff-hl
;;    :config
;;    (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
;;    (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+end_src
* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ag=

Install =ag= to provide search within projects (usually through
=projectile-ag=).

#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =avy=

Install =avy= to skip around the screen quickly.

#+begin_src emacs-lisp
  (use-package avy
    :bind*
    ("C-;" . evil-avy-goto-char-2))
#+end_src

** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

Use =M-/= for completion.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it doesn't
require any additional setup. I've bound its most useful command to =M-.=.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
;;    (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions)
  )
#+end_src

The =xref-find-definitions= function creates an =XREF= buffer of results if more
than one thing matches. That's inconvenient; I'd rather use Ivy to select among
them.

#+begin_src emacs-lisp
  (use-package ivy-xref
    :init
    (setq xref-show-definitions-function #'ivy-xref-show-defs))
#+end_src

** =flycheck=

I'd like to enable flycheck all kinds of places.

#+begin_src emacs-lisp
  (use-package let-alist)
  (use-package flycheck
    :init (global-flycheck-mode))
#+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
;;    (use-package evil-magit)
    (use-package with-editor)

    (setq magit-push-always-verify nil
          git-commit-summary-max-length 50)

;;    (add-hook 'with-editor-mode-hook 'evil-insert-state)
  )
#+end_src

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+begin_src emacs-lisp
  (use-package ghub)
  (use-package forge)
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . projectile-ag)

    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

;;    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion rspec-compilation-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil))
#+end_src

** =restclient=

#+begin_src emacs-lisp
  (use-package restclient)
  (use-package company-restclient
    :config
    (add-to-list 'company-backends 'company-restclient))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree)
#+end_src
* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

** YAML

Ensure that we always use =fixed-pitch= fonts for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :config
    (add-hook 'yaml-mode-hook (lambda () (variable-pitch-mode 0))))
#+end_src

* Publishing and task management with Org-mode

Including =org-tempo= restores the =<s=-style easy-templates that were
deprecated in Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my
[[file:~/.dotfiles/email/.mailcap][mailcap]]. This clears the existing MIME mapping, parses my personal mailcap, and
tells Org to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
;;  (use-package org
;;    :ensure org-plus-contrib
;;    :config
;;    (require 'org-tempo)

;;    (add-hook 'org-mode-hook
;;              '(lambda ()
;;                 (setq mailcap-mime-data '())
;;                 (mailcap-parse-mailcap "~/.mailcap")
;;                 (setq org-file-apps
;;                       '((remote . emacs)
;;                         ("mobi" . "fbreader %s")
;;                         (system . mailcap)
;;                         ("md" . emacs)
;;                         ("org" . emacs)
;;                         (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+begin_src emacs-lisp
  (setq org-ellipsis "⤵")
#+end_src

This hides the slashes and stars that denote /emphasis/ and *bold* text.

#+begin_src emacs-lisp
  (setq org-hide-emphasis-markers t)
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+end_src

Don't indent newly expanded blocks, even if they're under a heading.

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src

** Task management and agenda views

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files. I've also
got some annual OKRs in =goals.org=.

I also keep a schedule in =events.org=. Plus some recurring events in,
reasonably, a =recurring-events.org= file. Those are (mostly) structured as
=org-habit= items so they can recur according to a schedule.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file
                               (org-file-path "events.org")
                               (org-file-path "habits.org")
                               (org-file-path "recurring-events.org")
                               (org-file-path "work.org")))
#+end_src

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+begin_src emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src
