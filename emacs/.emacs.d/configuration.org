#+TITLE: Emacs Configuration
#+AUTHOR: Brian Collison
#+EMAIL: brian@briancollison.com
#+OPTIONS: num:nil
#+PROPERTY: header-args:emacs-lisp

* Introduction
This configuration started off as a clone of https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org
Some content from the original source is still present. I have made an attempt to understand the packages that I
have in this configuration as I increase my utilization of emacs.
I've also started pulling things in from System Crafters' [[https://github.com/daviwil/emacs-from-scratch/][Emacs From Scratch]] videos/repository

* Envirionment setup
emacs needs to run some utilties like gpg, and mbsync. We need to make sure these are on the PATH
#+begin_src emacs-lisp
  (setenv "PATH"
    (concat
     "/usr/local/bin" ":"
     "/Library/TeX/texbin" ":"
     (getenv "PATH")
    )
  )
#+end_src
* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes the
initial setup for =package.el= and ensures that =use-package= is installed, since I
wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+end_src

Disable TLS 1.3; ELPA has higher standards. That'll be the default in Emacs
26.3, I think, but I'm not there yet.

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* gpg stuff
(probably really just need to put gpg on the path? but this appears to work)
#+begin_src emacs-lisp
(require 'epa-file)
(custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
(epa-file-enable)
#+end_src

* Some shortcuts to help tweaking this configuration
This was repurposed from: https://github.com/mrvdb/emacs-config
The config file gets openened *a lot* because I tend to fiddle with this config at least once a day. So, it warrants it's own keybinding.

#+begin_src emacs-lisp
  (defun mrb/open-config ()
    (interactive)
    (find-file config-file))
  (global-set-key (kbd "C-~") 'mrb/open-config)
#+end_src

* UI preferences
The following variables are used to tweak some of the configuration pieces for use in the live streams so you might need to adjust them for your local machine if you try to use this configuration directly.

#+begin_src emacs-lisp
  ;; You will most likely need to adjust this font size for your system!
  (defvar efs/default-font-size 150)
  (defvar efs/default-variable-font-size 150)

  ;; Make frame transparency overridable
  (defvar efs/frame-transparency '(100 . 100))
#+end_src

* Set personal information
** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Brian Collison"
        user-mail-address "brian@briancollison.com"
        calendar-latitude 33.1581
        calendar-longitude -117.3506
        calendar-location-name "Carlsbad, CA")
#+END_SRC

** Access my netrc data

I store a few credentials in a =.netrc= file. This is a convenient way
to store not-too-terribly-sensitive secrets.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)

  (setq netrc-file "~/.netrc")

  (defun netrc-username (machine)
    "Helper function to extract a username from my netrc."
    (car (netrc-credentials machine)))

  (defun netrc-password (machine)
    "Helper function to extract a password from my netrc."
    (cadr (netrc-credentials machine)))
#+END_SRC

* Use =sensible-defaults.el=

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
  (load-file "~/Personal/projects/sensible-defaults.el/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

* More UI stuff

** Window management
Seeing what a vanilla install of bufler looks like to manage buffers
#+begin_src emacs-lisp
(use-package bufler
  :bind (("C-M-j" . bufler-switch-buffer)
         ("C-M-k" . bufler-workspace-frame-set)))
#+end_src
** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Font Configuration

I am using the [[https://github.com/tonsky/FiraCode][Fira Code]] and [[https://fonts.google.com/specimen/Cantarell][Cantarell]] fonts for this configuration which will more than likely need to be installed on your machine.  Both can usually be found in the various Linux distro package managers or downloaded from the links above.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height efs/default-font-size)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil :font "Cantarell" :height efs/default-variable-font-size :weight 'regular)
#+end_src

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (column-number-mode)
  (global-display-line-numbers-mode t)

  ;; Set frame transparency
  (set-frame-parameter (selected-frame) 'alpha efs/frame-transparency)
  (add-to-list 'default-frame-alist `(alpha . ,efs/frame-transparency))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  mu4e-main-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
 #+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Load up a theme
I'm currently using the "zenburn" theme.

#+BEGIN_SRC emacs-lisp
    ;;  (use-package doom-themes
    ;;    :init (load-theme 'doom-gruvbox t))

   (use-package zenburn-theme
    :config
      (load-theme `zenburn t))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+begin_src emacs-lisp
    (defun hrs/apply-theme ()
      "Apply the `zenburn' theme."
      (interactive)
      (load-theme 'zenburn t)
      ;;(transparency 100)
      )

     (if (daemonp)
	  (add-hook 'after-make-frame-functions
		    (lambda (frame)
		      (with-selected-frame frame (hrs/apply-theme))))
	(hrs/apply-theme))
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Better Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive and rich (yet still minimal) mode line configuration for Emacs.  The default configuration is quite good but you can check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need to run `M-x all-the-icons-install-fonts` so that mode line icons display correctly.

#+begin_src emacs-lisp

(use-package all-the-icons)

(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :custom ((doom-modeline-height 15)))

#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][which-key]] is a useful UI panel that appears when you start pressing any key binding in Emacs to offer you all possible completions for the prefix.  For example, if you press =C-c= (hold control and press the letter =c=), a panel will appear at the bottom of the frame displaying all of the bindings under that prefix and which command they run.  This is very useful for learning the possible key bindings in the mode of your current buffer.

#+begin_src emacs-lisp

  (use-package which-key
    :defer 0
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 1))

#+end_src

** Ivy and Counsel

[[https://oremacs.com/swiper/][Ivy]] is an excellent completion framework for Emacs.  It provides a minimal yet powerful selection menu that appears when you open files, switch buffers, and for many other tasks in Emacs.  Counsel is a customized set of commands to replace `find-file` with `counsel-find-file`, etc which provide useful commands for each of the default completion commands.

[[https://github.com/Yevgnen/ivy-rich][ivy-rich]] adds extra columns to a few of the Counsel commands to provide more information about each item.

#+begin_src emacs-lisp

    (use-package ivy
      :diminish
      :bind (("C-s" . swiper)
             :map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             ("C-l" . ivy-alt-done)
             ("C-j" . ivy-next-line)
             ("C-k" . ivy-previous-line)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-l" . ivy-done)
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :config
      (ivy-mode 1))

;;    (use-package ivy-rich
;;      :ensure t
;;      :config (ivy-rich-mode 1))

    (use-package counsel
      :bind (("C-M-j" . 'counsel-switch-buffer)
             :map minibuffer-local-map
             ("C-r" . 'counsel-minibuffer-history))
      :custom
      (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
      :config
      (counsel-mode 1))

#+end_src

*** Improved Candidate Sorting with prescient.el

prescient.el provides some helpful behavior for sorting Ivy completion candidates based on how recently or frequently you select them.  This can be especially helpful when using =M-x= to run commands that you don't have bound to a key but still need to access occasionally.

This Prescient configuration is optimized for use in System Crafters videos and streams, check out the [[https://youtu.be/T9kygXveEz0][video on prescient.el]] for more details on how to configure it!

#+begin_src emacs-lisp

  (use-package ivy-prescient
    :after counsel
    :custom
    (ivy-prescient-enable-filtering nil)
    :config
    ;; Uncomment the following line to have sorting remembered across sessions!
    ;(prescient-persist-mode 1)
    (ivy-prescient-mode 1))

#+end_src

** Helpful Help Commands

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Text Scaling

This is an example of using [[https://github.com/abo-abo/hydra][Hydra]] to design a transient key binding for quickly adjusting the scale of the text on screen.  We define a hydra that is bound to =C-s t s= and, once activated, =j= and =k= increase and decrease the text scale.  You can press any other key (or =f= specifically) to exit the transient key map.

#+begin_src emacs-lisp

    ;; (use-package hydra
    ;;   :defer t)

    ;; (defhydra hydra-text-scale (:timeout 4)
    ;;   "scale text"
    ;;   ("j" text-scale-increase "in")
    ;;   ("k" text-scale-decrease "out")
    ;;   ("f" nil "finished" :exit t))

  ;;  (efs/leader-keys
  ;;    "ts" '(hydra-text-scale/body :which-key "scale text"))

#+end_src

** Switch and rebalance windows when splitting
When splitting a window, I invariably want to switch to the new window. This makes that automatic.

#+begin_src emacs-lisp

  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)

#+end_src

** Always kill current buffer
Assume that I always want to kill the current buffer when hitting C-x k.

#+begin_src emacs-lisp

  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)

#+end_src

** Two window split toggle
#+begin_src emacs-lisp
(defun window-split-toggle ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (> (length (window-list)) 2)
      (error "Can't toggle with more than 2 windows!")
    (let ((func (if (window-full-height-p)
                    #'split-window-vertically
                  #'split-window-horizontally)))
      (delete-other-windows)
      (funcall func)
      (save-selected-window
        (other-window 1)
        (switch-to-buffer (other-buffer))))))
#+end_src

* Development

** Languages

*** IDE Features with lsp-mode

**** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp

  (defun efs/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . efs/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :config
    (lsp-enable-which-key-integration t))

#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))

#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp

  (use-package lsp-treemacs
    :after lsp)

#+end_src

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things by name in your code.  When you run these commands, a prompt will appear in the minibuffer allowing you to type part of the name of a symbol in your code.  Results will be populated in the minibuffer so that you can find what you're looking for and jump to that location in the code upon selecting the result.

Try these commands with =M-x=:

 =lsp-ivy-workspace-symbol=  Search for a symbol name in the current project workspace
 =lsp-ivy-global-workspace-symbol=  Search for a symbol name in all active project workspaces

#+begin_src emacs-lisp

  (use-package lsp-ivy
    :after lsp)

#+end_src

*** Debugging with dap-mode

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]].  You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp

 ;; (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
   ;; :commands dap-debug
   ;; :config
    ;; Set up Node debugging
   ;; (require 'dap-node)
   ;; (dap-node-setup) ;; Automatically installs Node debug adapter if needed

    ;; Bind `C-c l d` to `dap-hydra` for easy access
    ;; (general-define-key
    ;;   :keymaps 'lsp-mode-map
    ;;   :prefix lsp-keymap-prefix
    ;;   "d" '(dap-hydra t :wk "debugger")))

#+end_src

*** TypeScript

This is a basic configuration for the TypeScript language so that =.ts= files activate =typescript-mode= when opened.  We're also adding a hook to =typescript-mode-hook= to call =lsp-deferred= so that we activate =lsp-mode= to get LSP features every time we edit TypeScript code.

#+begin_src emacs-lisp

  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2))

#+end_src

*Important note!*  For =lsp-mode= to work with TypeScript (and JavaScript) you will need to install a language server on your machine.  If you have Node.js installed, the easiest way to do that is by running the following command:

#+begin_src shell :tangle no

npm install -g typescript-language-server typescript

#+end_src

This will install the [[https://github.com/theia-ide/typescript-language-server][typescript-language-server]] and the TypeScript compiler package.

*** Python

We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no

pip install --user "python-language-server[all]"

#+end_src

There are a number of other language servers for Python so if you find that =pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

#+begin_src emacs-lisp

  (use-package python-mode
    :ensure t
    :hook (python-mode . lsp-deferred)
    :custom
    ;; NOTE: Set these if Python 3 is called "python3" on your system!
    ;; (python-shell-interpreter "python3")
    ;; (dap-python-executable "python3")
    (dap-python-debugger 'debugpy)
    :config
    (require 'dap-python))


#+end_src

You can use the pyvenv package to use =virtualenv= environments in Emacs.  The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and =dap-mode= to use the virtual environment when they are loaded, just select the path to your virtual environment before loading your project.

#+begin_src emacs-lisp

  (use-package pyvenv
    :after python-mode
    :config
    (pyvenv-mode 1))

#+end_src

*** Golang
#+begin_src emacs-lisp
  (use-package go-mode)
#+end_src

** Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp

  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind (:map company-active-map
           ("<tab>" . company-complete-selection))
          (:map lsp-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src

** Projectile

[[https://projectile.mx/][Projectile]] is a project management library for Emacs which makes it a lot easier to navigate around code projects for various languages.  Many packages integrate with Projectile so it's a good idea to have it installed even if you don't use its commands directly.

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/Projects/Code")
      (setq projectile-project-search-path '("~/Projects/Code")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :after projectile
    :config (counsel-projectile-mode))

#+end_src

** Magit

[[https://magit.vc/][Magit]] is the best Git interface I've ever used.  Common Git operations are easy to execute quickly using Magit's command panel system.

#+begin_src emacs-lisp

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  (use-package forge
    :after magit)

#+end_src

** Commenting

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))

#+end_src

** Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is useful in programming modes because it colorizes nested parentheses and brackets according to their nesting depth.  This makes it a lot easier to visually match parentheses in Emacs Lisp code without having to count them yourself.

#+begin_src emacs-lisp

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Jira
#+begin_src emacs-lisp
  (use-package org-jira
    :config
(setq jiralib-url "https://rakenapp.atlassian.net/")
  )
#+end_src

* Publishing and task management with Org-mode

** Better Font Faces
 The =efs/org-font-setup= function configures various text faces to tweak the sizes of headings and use variable width fonts in most cases so that it looks more like we're editing a document in =org-mode=.  We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

 #+begin_src emacs-lisp

      (defun efs/org-font-setup ()
        ;; Replace list hyphen with dot
   ;;     (font-lock-add-keywords 'org-mode
   ;;                             '(("^ *\\([-]\\) "
   ;;				(0 (prog1 () (compose-region (match-beginning 1) (match-uend 1)  "•"))))))

        ;; Set faces for heading levels
        (dolist (face '((org-level-1 . 1.2)
                        (org-level-2 . 1.1)
                        (org-level-3 . 1.05)
                        (org-level-4 . 1.0)
                        (org-level-5 . 1.1)
                        (org-level-6 . 1.1)
                        (org-level-7 . 1.1)
                        (org-level-8 . 1.1)))
          (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

        ;; Ensure that anything that should be fixed-pitch in Org files appears that way
        (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
        (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
     ;; want this for tables... would be nice to only do this in tables...
        (set-face-attribute 'org-link nil    :inherit 'fixed-pitch)
     ;; want this for tables... would be nice to only do this in tables...
        (set-face-attribute 'org-date nil    :inherit 'fixed-pitch)

        (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
        (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
        (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
        (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
        (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
        (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
        (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))

 #+end_src

** Other org UI concerns
org-appear will show the formatting text once you get inside the block
#+begin_src emacs-lisp
;;  (use-package org-appear
;;   :hook (org-mode-hook . org-appear-mode))
#+end_src
** Basic Config

This section contains the basic configuration for =org-mode= plus the configuration for Org agendas and capture templates.  There's a lot to unpack in here so I'd recommend watching the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] for a full explanation.

#+begin_src emacs-lisp

  (defun efs/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (setq org-directory "~/Documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (use-package org
    :pin org
    :commands (org-capture org-agenda)
    :hook (org-mode . efs/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")

    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (setq org-agenda-files
          `(,(org-file-path "Tasks.org")
               ,(org-file-path "Habits.org")
               ,(org-file-path "Birthdays.org")))

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)

    (setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
        (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    (setq org-refile-targets
      '(("Archive.org" :maxlevel . 1)
        ("home.org" :maxlevel . 2)))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
      '((:startgroup)
         ; Put mutually exclusive tags here
         (:endgroup)
         ("@errand" . ?E)
         ("@home" . ?H)
         ("@work" . ?W)
         ("agenda" . ?a)
         ("planning" . ?p)
         ("publish" . ?P)
         ("batch" . ?b)
         ("note" . ?n)
         ("idea" . ?i)))

    ;; Configure custom agenda views
    (setq org-agenda-custom-commands
     '(("d" "Dashboard"
       ((agenda "" ((org-deadline-warning-days 7)))
        (todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))
        (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

      ("n" "Next Tasks"
       ((todo "NEXT"
          ((org-agenda-overriding-header "Next Tasks")))))

      ("W" "Work Tasks" tags-todo "+work-email")

      ;; Low-effort next actions
      ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
       ((org-agenda-overriding-header "Low Effort Tasks")
        (org-agenda-max-todos 20)
        (org-agenda-files org-agenda-files)))

      ("w" "Workflow Status"
       ((todo "WAIT"
              ((org-agenda-overriding-header "Waiting on External")
               (org-agenda-files org-agenda-files)))
        (todo "REVIEW"
              ((org-agenda-overriding-header "In Review")
               (org-agenda-files org-agenda-files)))
        (todo "PLAN"
              ((org-agenda-overriding-header "In Planning")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "BACKLOG"
              ((org-agenda-overriding-header "Project Backlog")
               (org-agenda-todo-list-sublevels nil)
               (org-agenda-files org-agenda-files)))
        (todo "READY"
              ((org-agenda-overriding-header "Ready for Work")
               (org-agenda-files org-agenda-files)))
        (todo "ACTIVE"
              ((org-agenda-overriding-header "Active Projects")
               (org-agenda-files org-agenda-files)))
        (todo "COMPLETED"
              ((org-agenda-overriding-header "Completed Projects")
               (org-agenda-files org-agenda-files)))
        (todo "CANC"
              ((org-agenda-overriding-header "Cancelled Projects")
               (org-agenda-files org-agenda-files)))))))

    (efs/org-font-setup))

#+end_src

*** Nicer Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in =org-mode= buffers with nicer looking characters that you can control.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] which we may cover in a later video.

#+begin_src emacs-lisp

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

*** Center Org Buffers

We use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] to center =org-mode= buffers for a more pleasing writing experience as it centers the contents of the buffer horizontally to seem more like you are editing a document.  This is really a matter of personal preference so you can remove the block below if you don't like the behavior.

#+begin_src emacs-lisp

  (defun efs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . efs/org-mode-visual-fill))

#+end_src

** Configure Babel Languages

To execute or export code in =org-mode= code blocks, you'll need to set up =org-babel-load-languages= for each language you'd like to use.  [[https://orgmode.org/worg/org-contrib/babel/languages.html][This page]] documents all of the languages that you can use with =org-babel=.

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
	   (java . t)
          (python . t)))

    (push '("conf-unix" . conf-unix) org-src-lang-modes))

#+end_src

** Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("ja" . "src java"))
    (add-to-list 'org-structure-template-alist '("sql" . "src sql"))
    (add-to-list 'org-structure-template-alist '("js" . "src javascript"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))

#+end_src


 I'd like the initial scratch buffer to be in Org:

 #+begin_src emacs-lisp
   (setq initial-major-mode 'org-mode)
 #+end_src

*** org-protocol?
#+begin_src emacs-lisp
  (server-start)
  (require 'org-protocol)
#+end_src
** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.
Other interesting characters are ▼, ↴, ⬎, ⤷, ⤵ and ⋱. (via https://endlessparentheses.com/changing-the-org-mode-ellipsis.html )
#+begin_src emacs-lisp
  (setq org-ellipsis "⬎")
#+end_src

Including =org-tempo= restores the =<s=-style easy-templates that were
deprecated in Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my
[[file:~/.dotfiles/email/.mailcap][mailcap]]. This clears the existing MIME mapping, parses my personal mailcap, and
tells Org to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
;;  (use-package org
;;    :ensure org-plus-contrib
;;    :config
;;    (require 'org-tempo)

;;    (add-hook 'org-mode-hook
;;              '(lambda ()
;;                 (setq mailcap-mime-data '())
;;                 (mailcap-parse-mailcap "~/.mailcap")
;;                 (setq org-file-apps
;;                       '((remote . emacs)
;;                         ("mobi" . "fbreader %s")
;;                         (system . mailcap)
;;                         ("md" . emacs)
;;                         ("org" . emacs)
;;                         (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Task management and agenda views

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+begin_src emacs-lisp
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
	(concat (org-file-path "archive.org") "::* From %s"))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files. I've also
got some annual OKRs in =goals.org=.

I also keep a schedule in =events.org=. Plus some recurring events in,
reasonably, a =recurring-events.org= file. Those are (mostly) structured as
=org-habit= items so they can recur according to a schedule.

#+begin_src emacs-lisp
    (setq org-agenda-files (list org-index-file
                                 (org-file-path "events.org")
                                 (org-file-path "habits.org")
                                 (org-file-path "recurring-events.org")
                                   (org-file-path "home.org")
                                 (org-file-path "work.org")
                                 (org-file-path ".org-gcal/raken.org")))
#+end_src

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+begin_src emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

*** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/documents/notes/blog-ideas.org=,
- Maintain a todo list in =~/documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+begin_src emacs-lisp
    (setq org-capture-templates
          `(("B" "Blog idea"
             entry
             (file ,(org-file-path  "notes/blog-ideas.org"))
             "* %?\n")

            ("e" "Email" entry
             (file+headline org-index-file "Inbox")
             "* TODO %?\n\n%a\n\n")

            ("j" "Work task"
             entry
             (file+headline ,(org-file-path "work.org") "Tasks")
             "* TODO %?\n")

            ("s" "Subscribe to an RSS feed"
             plain
             (file ,(org-file-path "rss-feeds.org"))
             "*** [[%^{Feed URL}][%^{Feed name}]]")

            ("p" "Protocol" entry (file+headline  ,(org-file-path "index.org") "Inbox")
             "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")

            ("L" "Protocol Link" entry (file+headline ,(org-file-path "index.org") "Links")
             "* %? [[%:link][%:description]] \nCaptured On: %U")

               ;; coming from org-protocol via the browser.
            ("z" "A link, for reading later." entry
             (file+headline ,(org-file-path "index.org") "Reading List")
             "* [[%:link][%:description]]\n%u\n\n%i"
             :empty-lines 1)

            ("t" "Todo"
             entry
             (file+headline ,(org-file-path "index.org") "Inbox")
             "* TODO %?\n")
            ("u" "UA Reading"
                table-line
                (file+headline, (org-file-path "health.org") "Uric Acid")
                   "|%u|%?| | | |")
            ("w" "Weight"
                table-line
                (file+headline, (org-file-path "health.org") "Weight")
                   "|%u|%?| |")
          ))
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

*** Keybindings

Bind a few handy keys.

#+begin_src emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+end_src

Hit =C-c i= to quickly open up my todo list.

#+begin_src emacs-lisp
  (defun hrs/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'hrs/open-index-file)
#+end_src

Hit =M-n= to quickly open up a capture template for a new todo.

#+begin_src emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+end_src

Hit =C-c w= to quickly open up my work todo list.

#+begin_src emacs-lisp
  (defun hrs/open-work-file ()
    "Open the work TODO list."
    (interactive)
    (find-file (org-file-path "work.org"))
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c w") 'hrs/open-work-file)
#+end_src
** Exporting

Allow export to markdown and beamer (for presentations).

#+begin_src emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+end_src

Allow =babel= to evaluate Emacs lisp, java, Ruby, =ditaa=, Graphviz, or Gnuplot code.

#+begin_src emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (ditaa . t)
     (dot . t)
     (java . t)
     (gnuplot . t)))
#+end_src

Default behavior for ob-java differs from most babel languages in two ways:

ob-java defaults to scripting mode (:results output)
ob-java writes tempfiles to the current directory instead of the babel temporary directory

Let's make it more like most
#+begin_src emacs-lisp
  (setq org-babel-java-command "/usr/local/java/bin/java")
  (setq org-babel-java-compiler "/usr/local/java/bin/javac")
    ;;(nconc org-babel-default-header-args:java
    ;;       '((:dir . nil)
    ;;         (:results . value)))
#+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
    (setq org-confirm-babel-evaluate nil)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Associate the "dot" language with the =graphviz-dot= major mode.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+end_src

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

Include the =minted= package in all of my LaTeX exports.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+end_src

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

* Knowledge Managment

** My brain isn't the best device to store information, let's play with org-brain

#+begin_src emacs-lisp
(use-package org-brain :ensure t
  :init
  (setq org-brain-path (org-file-path "org-brain"))
  ;; For Evil users
;;  (with-eval-after-load 'evil
;;    (evil-set-initial-state 'org-brain-visualize-mode 'emacs))
  :config
  (bind-key "C-c b" 'org-brain-prefix-map org-mode-map)
  (setq org-id-track-globally t)
  (setq org-id-locations-file (org-file-path ".org-id-locations"))
  (add-hook 'before-save-hook #'org-brain-ensure-ids-in-buffer)
  (push '("b" "Brain" plain (function org-brain-goto-end)
          "* %i%?" :empty-lines 1)
        org-capture-templates)
  (setq org-brain-visualize-default-choices 'all)
  (setq org-brain-title-max-length 12)
  (setq org-brain-include-file-entries nil
        org-brain-file-entries-use-title nil))

;; Allows you to edit entries directly from org-brain-visualize
(use-package polymode
  :config
  (add-hook 'org-brain-visualize-mode-hook #'org-brain-polymode))
#+end_src

** Or... maybe I want to use org-roam for my PKM System?
#+begin_src emacs-lisp
(use-package org-roam
      :ensure t
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory (org-file-path "org-roam"))
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+end_src

** let's add a server for visualization, capture
#+begin_src emacs-lisp
  (use-package org-roam-server
    :ensure t
    :config
    (setq org-roam-server-host "127.0.0.1"
          org-roam-server-port 8580
          org-roam-server-authenticate nil
          org-roam-server-export-inline-images t
          org-roam-server-serve-files nil
          org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
          org-roam-server-network-poll t
          org-roam-server-network-arrows nil
          org-roam-server-network-label-truncate t
          org-roam-server-network-label-truncate-length 60
          org-roam-server-network-label-wrap-length 20))

  (require 'org-roam-protocol)
#+end_src

*** Let's play around with dailies
#+begin_src emacs-lisp
  (setq org-roam-dailies-directory (org-file-path "daily/"))
  (setq org-roam-dailies-capture-templates
      '(("p" "planned" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n"
         :olp ("Planned"))
        ("u" "unplanned" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n"
         :olp ("Unplanned"))
        ("j" "journal" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n"
         :olp ("Journal"))))
  (global-set-key (kbd "C-c d d") 'org-roam-dailies-find-today)
  (global-set-key (kbd "C-c d y") 'org-roam-dailies-find-yesterday)

#+end_src

* Email
#+BEGIN_SRC emacs-lisp
      (use-package org-mime)

    (add-to-list 'load-path "/usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e")
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/")
    (use-package mu4e
      :load-path ("/home/brian/Personal/projects/third-party/mu/mu4e"
                  "/usr/local/Cellar/mu/1.4.15/share/emacs/site-lisp/mu/mu4e"
                  "/usr/local/share/emacs/site-lisp/mu4e/"))

    (cond ((eq system-type 'gnu/linux)
         (setq mu4e-mu-binary "/usr/bin/mu"))
       ((eq system-type 'darwin)
         (setq mu4e-mu-binary "/usr/local/bin/mu")))
  ;  "mu4e no longer uses the mu4e-maildir and mu4e-user-mail-address-list variables; instead it uses the information it gets from mu (see the mu section above). If you have a non-default mu4e-mu-home, make sure to set it before mu4e starts."
  ;; (setq mu4e-maildir (expand-file-name "/home/brian/Maildir"))

      ; get mail
      (setq mu4e-get-mail-command "/usr/local/bin/mbsync -c ~/.mbsyncrc -a"
        ;; mu4e-html2text-command "w3m -T text/html" ;;using the default mu4e-shr2text
        mu4e-update-interval 600
        mu4e-headers-auto-update t
        mu4e-compose-signature-auto-include nil
        mu4e-compose-format-flowed t)

      ;; to view selected message in the browser, no signin, just html mail
      (add-to-list 'mu4e-view-actions
        '("ViewInBrowser" . mu4e-action-view-in-browser) t)

      ;; enable inline images
      (setq mu4e-view-show-images t)
      ;; use imagemagick, if available
      (when (fboundp 'imagemagick-register-types)
        (imagemagick-register-types))

      ;; every new email composition gets its own frame!
      (setq mu4e-compose-in-new-frame t)

      ;; don't save message to Sent Messages, IMAP takes care of this
      (setq mu4e-sent-messages-behavior 'delete)

      (add-hook 'mu4e-view-mode-hook #'visual-line-mode)

      ;; <tab> to navigate to links, <RET> to open them in browser
      (add-hook 'mu4e-view-mode-hook
        (lambda()
      ;; try to emulate some of the eww key-bindings
      (local-set-key (kbd "<RET>") 'mu4e~view-browse-url-from-binding)
      (local-set-key (kbd "<tab>") 'shr-next-link)
      (local-set-key (kbd "<backtab>") 'shr-previous-link)))

      ;; from https://www.reddit.com/r/emacs/comments/bfsck6/mu4e_for_dummies/elgoumx
      (add-hook 'mu4e-headers-mode-hook
            (defun my/mu4e-change-headers ()
        (interactive)
       (setq mu4e-headers-fields
              `((:human-date . 25) ;; alternatively, use :date
          (:flags . 6)
          (:from . 22)
          (:thread-subject . ,(- (window-body-width) 70)) ;; alternatively, use :subject
          (:size . 7)))))

      ;; if you use date instead of human-date in the above, use this setting
      ;; give me ISO(ish) format date-time stamps in the header list
      ;(setq mu4e-headers-date-format "%Y-%m-%d %H:%M")

      ;; spell check
      (add-hook 'mu4e-compose-mode-hook
          (defun my-do-compose-stuff ()
             "My settings for message composition."
             (visual-line-mode)
             (org-mu4e-compose-org-mode)
                 (use-hard-newlines -1)
             (flyspell-mode)))

      (require 'smtpmail)

      ;;rename files when moving
      ;;NEEDED FOR MBSYNC
      (setq mu4e-change-filenames-when-moving t)

      ;;set up queue for offline email
      ;;use mu mkdir  ~/Maildir/acc/queue to set up first
      (setq smtpmail-queue-mail nil)  ;; start in normal mode

      ;;from the info manual
      (setq mu4e-attachment-dir  "~/Downloads")

      (setq message-kill-buffer-on-exit t)
      (setq mu4e-compose-dont-reply-to-self t)

      (require 'org-mu4e)

      ;; convert org mode to HTML automatically
      (setq org-mu4e-convert-to-html t)

      ;;from vxlabs config
      ;; show full addresses in view message (instead of just names)
      ;; toggle per name with M-RET
      (setq mu4e-view-show-addresses 't)

      ;; don't ask when quitting
      (setq mu4e-confirm-quit nil)

      ;; from: https://www.reddit.com/r/emacs/comments/6ul9rz/email_html_rendering_mu4e_with_html2text_how_to/
      (require 'mu4e-contrib)

      (setq mu4e-html2text-command 'mu4e-shr2text)

      (setq shr-color-visible-luminance-min 80)

      (setq shr-color-visible-distance-min 5)

      ;; mu4e-context
      (setq mu4e-context-policy 'ask-if-none)
      (setq mu4e-compose-context-policy 'always-ask)
      (setq mu4e-contexts
        (list
         (make-mu4e-context
          :name "personal" ;;for bcollison-gmail
          :enter-func (lambda () (mu4e-message "Entering context personal"))
          :leave-func (lambda () (mu4e-message "Leaving context personal"))
          :match-func (lambda (msg)
            (when msg
          (mu4e-message-contact-field-matches
           msg '(:from :to :cc :bcc) "bcollison@gmail.com")))
          :vars '((user-mail-address . "bcollison@gmail.com")
            (user-full-name . "Brian Collison")
            (mu4e-sent-folder . "/bcollison-gmail/[bcollison].sent")
            (mu4e-drafts-folder . "/bcollison-gmail/[bcollison].drafts")
            (mu4e-trash-folder . "/bcollison-gmail/[bcollison].trash")
            (mu4e-refile-folder . "/bcollison-gmail/[bcollison].All Mail")
            (mu4e-compose-signature . (concat "Formal Signature\n" "Emacs 25, org-mode 9, mu4e 1.0\n"))
            (mu4e-compose-format-flowed . t)
            (smtpmail-queue-dir . "/home/brian/Maildir/bcollison-gmail/queue/cur")
            (message-send-mail-function . smtpmail-send-it)
            (smtpmail-smtp-user . "bcollison")
            (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
            (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
            (smtpmail-default-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-service . 587)
            (smtpmail-debug-info . t)
            (smtpmail-debug-verbose . t)
            (mu4e-maildir-shortcuts . ( ("/bcollison-gmail/INBOX"            . ?i)
                ("/bcollison-gmail/[bcollison].Raken" . ?r)
                ("/bcollison-gmail/[bcollison].sent" . ?s)
                ("/bcollison-gmail/[bcollison].trash"       . ?t)
                ("/bcollison-gmail/[bcollison].All Mail"       . ?l)
                ("/bcollison-gmail/[bcollison].actionable"  . ?a)
                ("/bcollison-gmail/[bcollison].wait"   . ?w)
                ("/bcollison-gmail/[bcollison].reference"   . ?F)
                ("/bcollison-gmail/[bcollison].inflight"   . ?f)
                ("/bcollison-gmail/[bcollison].drafts"    . ?d)
                ))))

         (make-mu4e-context
          :name "work" ;;for raken-gmail
          :enter-func (lambda () (mu4e-message "Entering context work"))
          :leave-func (lambda () (mu4e-message "Leaving context work"))
          :match-func (lambda (msg)
            (when msg
          (mu4e-message-contact-field-matches
           msg '(:from :to :cc :bcc) "brian.collison@rakenapp.com")))
          :vars '((user-mail-address . "brian.collison@rakenapp.com")
            (user-full-name . "Brian Collison")
            (mu4e-sent-folder . "/raken-gmail/[raken].sent")
            (mu4e-drafts-folder . "/raken-gmail/[raken].drafts")
            (mu4e-trash-folder . "/raken-gmail/[raken].trash")
            (mu4e-refile-folder . "/raken-gmail/[raken].All Mail")
            (mu4e-compose-signature . (concat "Formal Signature\n" "Emacs 25, org-mode 9, mu4e 1.0\n"))
            (mu4e-compose-format-flowed . t)
            (smtpmail-queue-dir . "/home/brian/Maildir/raken-gmail/queue/cur")
            (message-send-mail-function . smtpmail-send-it)
            (smtpmail-smtp-user . "brian.collison@rakenapp.com")
            (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
            (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
            (smtpmail-default-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-service . 587)
            (smtpmail-debug-info . t)
            (smtpmail-debug-verbose . t)
            (mu4e-maildir-shortcuts . ( ("/raken-gmail/INBOX"            . ?i)
                ("/raken-gmail/[raken].Raken" . ?r)
                ("/raken-gmail/[raken].sent" . ?s)
                ("/raken-gmail/[raken].trash"       . ?t)
                ("/raken-gmail/[raken].All Mail"       . ?l)
                ("/raken-gmail/[raken].actionable"  . ?a)
                ("/raken-gmail/[raken].wait"   . ?w)
                ("/raken-gmail/[raken].reference"   . ?F)
                ("/raken-gmail/[raken].inflight"   . ?f)
                ("/raken-gmail/[raken].drafts"    . ?d)
                ))))
         )
      )

  (global-set-key (kbd "C-\"") 'mu4e)

#+END_SRC

** Let's try and create a nice view in browser using xwdiget
#+begin_src emacs-lisp
  ;;(use-package mu4e-views
  ;;   :after mu4e
  ;;   :defer nil
  ;;   :bind (:map mu4e-headers-mode-map
  ;; 	    ("v" . mu4e-views-mu4e-select-view-msg-method) ;; select viewing method
  ;; 	    ("M-n" . mu4e-views-cursor-msg-view-window-down) ;; from headers window scroll the email view
  ;; 	    ("M-p" . mu4e-views-cursor-msg-view-window-up) ;; from headers window scroll the email view
  ;;         ("f" . mu4e-views-toggle-auto-view-selected-message) ;; toggle opening messages automatically when moving in the headers view
  ;; 	    )
  ;;   :config
  ;;   (setq mu4e-views-completion-method 'ivy) ;; use ivy for completion
  ;;   (setq mu4e-views-default-view-method "gnus") ;; make xwidgets default
  ;;   (mu4e-views-mu4e-use-view-msg-method "gnus") ;; select the default
  ;; ;;  (setq mu4e-views-next-previous-message-behaviour 'stick-to-current-window) ;; when pressing n and p stay in the current window
  ;;  (setq mu4e-views-auto-view-selected-message t) ;; automatically open messages when moving in the headers view
  ;;  )
#+end_src

* Calendar
Going to attempt to use org-gcal (I don't think I need bidirectional syncing, I just want org-agenda to show meetings
#+begin_src emacs-lisp
  (defun get-authinfo (host port)
    (let* ((netrc (netrc-parse (expand-file-name "~/.authinfo.gpg")))
        (hostentry (netrc-machine netrc host port port)))
    (when hostentry (netrc-get hostentry "password"))))
  (use-package org-gcal
    :ensure t
    :init
    (setq org-gcal-dir "~/Documents/org/.org-gcal/")
    :config
    (setq org-gcal-client-id "104759143706-1kj1r66cs5ij3ssfreasf5cqlavbrqjn.apps.googleusercontent.com"
org-gcal-client-secret (get-authinfo "gcal.api" "9999")
org-gcal-fetch-file-alist '(("brian.collison@rakenapp.com" . "/Users/brian.collison/Documents/org/.org-gcal/raken.org")
)))

(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
#+end_src
* Reading things

** RSS with =elfeed=

Install elfeed and load up my feeds.

#+begin_src emacs-lisp
  (use-package elfeed
    :config
    (elfeed-set-max-connections 32)
    (setq elfeed-search-filter "@1-week-ago +unread "))


  (use-package elfeed-org
    :config
    (progn
      (elfeed-org)
             (setq rmh-elfeed-org-files (list (org-file-path "rss-feeds.org")))))
#+end_src

Sort RSS feeds first by tag (=comics= come before =haskell=, for example), then
by name of the feed, and finally by publication date.

#+begin_src emacs-lisp
  (defun hrs/custom-elfeed-sort (a b)
    (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
           (b-tags (format "%s" (elfeed-entry-tags b)))
           (a-title (elfeed-feed-title (elfeed-entry-feed a)))
           (b-title (elfeed-feed-title (elfeed-entry-feed b))))
      (if (string= a-tags b-tags)
          (if (string= a-title b-title)
              (< (elfeed-entry-date b) (elfeed-entry-date a))
            (string< b-title a-title))
        (string< a-tags b-tags))))

  (setf elfeed-search-sort-function #'hrs/custom-elfeed-sort)
#+end_src

Open =elfeed= with =C-c r=:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'elfeed)
#+end_src

Use =o= to browse the entry in a Web browser and open links with =C-c C-o=.

#+begin_src emacs-lisp
;;  (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode)
;;  (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)

;;  (evil-add-hjkl-bindings elfeed-search-mode-map)
;;  (evil-add-hjkl-bindings elfeed-show-mode-map)

;;  (define-key elfeed-show-mode-map "o" 'elfeed-show-visit)
;;  (define-key elfeed-search-mode-map "o" 'elfeed-search-browse-url)

;;  (define-key elfeed-show-mode-map (kbd "C-c C-o") 'org-open-at-point)
#+end_src

Some external integrations need access to the current entry at point:

#+begin_src emacs-lisp
  (defun hrs/elfeed-current-entry ()
    (cond ((eq major-mode 'elfeed-show-mode)
           elfeed-show-entry)
          ((eq major-mode 'elfeed-search-mode)
           (elfeed-search-selected t))))
#+end_src
* Editing settings
** Show my available key-bindings
#+begin_src emacs-lisp
  (use-package free-keys)
#+end_src

* Set custom keybindings
** Just a few handy functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
#+end_src

Remap when working in terminal Emacs.

#+begin_src emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+end_src

** Mac swapping of option/command
It's easier for my thumb to hit command rather than option on my mac... let's turn the command key int the meta key

#+begin_src emacs-lisp
    (cond  ((eq system-type 'darwin)
         (setq mac-option-modifier 'super)
         (setq mac-command-modifier 'meta)))
#+end_src

* Extra
** sublima Sublime-like Scratch files
I use sublime as a temporary place to do text modification/searching. I like how
sublime auto-saves things. Someone else enjoyed that too. Here is his attempt
at recreating that
#+begin_src emacs-lisp
  (load-file "~/Personal/projects/emacs-libraries/sublima/sublima.el")
(global-set-key (kbd "<f7>") 'sublima-scratch)
(global-set-key (kbd "<f8>") 'previous-buffer)
(global-set-key (kbd "<f9>") 'next-buffer)
#+end_src
** Slack? let's give it a go (removed verve team)
#+begin_src emacs-lisp
(use-package slack
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
  (setq slack-prefer-current-team t)
  :config
   )
#+end_src
** show gcal calendar via gcalcli
via http://pragmaticemacs.com/emacs/how-i-view-my-google-calendar-agenda-in-emacs/
#+begin_src emacs-lisp
;; define function to display ansi colours for a buffer
;; http://stackoverflow.com/questions/23378271/how-do-i-display-ansi-color-codes-in-emacs-for-any-mode
(require 'ansi-color)
(defun display-ansi-colors ()
  (interactive)
  (ansi-color-apply-on-region (point-min) (point-max)))

(defun bjm/open-gcal-agenda ()
  "Open my google calendar agenda file. The agenda is displayed in the buffer *gcal*."
  (interactive)
  ;; set name of calendar buffer and location of file containing my agenda
  (let ((tmp-buff-name "*gcal*") (cal-file (expand-file-name "~/.gcal-files/gcal-agenda")))
    ;; switch to calendar buffer
    (switch-to-buffer tmp-buff-name)
    ;; turn off read only to overwrite if buffer exists
    (read-only-mode -1)
    ;; clear buffer
    (erase-buffer)
    ;; insert agenda file
    (insert-file-contents cal-file)
    ;; turn on colours
    (display-ansi-colors)
    ;; turn on special mode
    (special-mode)
    ;; turn off line wrapping
    (visual-line-mode -1)))

  (global-set-key (kbd "C-?") 'bjm/open-gcal-agenda)
#+end_src
