#+TITLE: Emacs Configuration
#+AUTHOR: Brian Collison
#+EMAIL: brian@briancollison.com
#+OPTIONS: num:nil
#+PROPERTY: header-args:emacs-lisp

* Introduction
This configuration started off as a clone of https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org
Much of the content from the original source is still present. I have made an attempt to understand the packages that I
have in this configuration as I increase my utilization of emacs.
I've started pulling things in from System Crafters efs.

* Configure =use-package=

I use =use-package= to install and configure my packages. My =init.el= includes the
initial setup for =package.el= and ensures that =use-package= is installed, since I
wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Always compile packages, and use the newest version available.

#+begin_src emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+end_src

Disable TLS 1.3; ELPA has higher standards. That'll be the default in Emacs
26.3, I think, but I'm not there yet.

#+begin_src emacs-lisp
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

* Some shortcuts to help tweaking this configuration
This was repurposed from: https://github.com/mrvdb/emacs-config
#+begin_src emacs-lisp
  (defun mrb/compile-config ()
    (interactive)
    (org-babel-load-file config-file)
    (byte-recompile-directory user-emacs-directory 0)
  )
#+end_src

The config file =mrb.org= gets openened *a lot* because I tend to fiddle with this config at least once a day. So, it warrants it's own keybinding.

#+begin_src emacs-lisp
  (defun mrb/open-config ()
    (interactive)
    (find-file config-file))
  ;; I wanted something with '~'
  (global-set-key (kbd "C-~") 'mrb/open-config)
#+end_src

* Use =sensible-defaults.el=

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+begin_src emacs-lisp
  (load-file "~/Personal/projects/sensible-defaults.el/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

* Set personal information

** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Brian Collison"
        user-mail-address "brian@briancollison.com"
        calendar-latitude 33.1581
        calendar-longitude -117.3506
        calendar-location-name "Carlsbad, CA")
#+END_SRC

** Access my netrc data

I store a few credentials in a =.netrc= file. This is a convenient way
to store not-too-terribly-sensitive secrets.

#+BEGIN_SRC emacs-lisp
  (require 'netrc)

  (setq netrc-file "~/.netrc")

  (defun netrc-username (machine)
    "Helper function to extract a username from my netrc."
    (car (netrc-credentials machine)))

  (defun netrc-password (machine)
    "Helper function to extract a password from my netrc."
    (cadr (netrc-credentials machine)))
#+END_SRC

* Add =resources= to =load-path=

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+end_src

* Utility functions

Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun hrs/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
              (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun hrs/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun hrs/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun hrs/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun hrs/insert-password ()
    (interactive)
    (shell-command "pwgen 30 -1" t))

  (defun hrs/notify-send (title message)
    "Display a desktop notification by shelling out to `notify-send'."
    (call-process-shell-command
     (format "notify-send -t 2000 \"%s\" \"%s\"" title message)))
#+end_src

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+begin_src emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src

** Use fancy lambdas

Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src

** Load up a theme
I'm currently using the "zenburn" theme.

#+BEGIN_SRC emacs-lisp
(setq zenburn-scale-org-headlines t)
(setq zenburn-use-variable-pitch t)
(setq zenburn-scale-outline-headlines t)

  (use-package zenburn-theme
    :config
    (load-theme `zenburn t))

 (defun transparency (value)
   "Sets the transparency of the frame window. 0=transparent/100=opaque."
   (interactive "nTransparency Value 0 - 100 opaque:")
   (set-frame-parameter (selected-frame) 'alpha value))

 (defun hrs/apply-theme ()
   "Apply the `zenburn' theme."
   (interactive)
   (load-theme 'zenburn t)
   (transparency 100))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+begin_src emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (hrs/apply-theme))))
    (hrs/apply-theme))
#+end_src

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+begin_src emacs-lisp
   (use-package minions
     :config
     (setq minions-mode-line-lighter ""
           minions-mode-line-delimiters '("" . ""))
     (minions-mode 1))
#+end_src

** Disable visual bell (Disabled)

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
;;  (setq ring-bell-function 'ignore)
#+end_src

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src

** Set default font and configure font resizing

I'm partial to Inconsolata for code and Libre Baskerville for prose.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
  (setq hrs/default-fixed-font "Inconsolata")
  (setq hrs/default-fixed-font-size 140)
  (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
  (set-face-attribute 'default nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)
  (set-face-attribute 'fixed-pitch nil
                      :family hrs/default-fixed-font
                      :height hrs/current-fixed-font-size)

  (setq hrs/default-variable-font "Libre Baskerville")
  (setq hrs/default-variable-font-size 120)
  (setq hrs/current-variable-font-size hrs/default-variable-font-size)
  (set-face-attribute 'variable-pitch nil
                      :family hrs/default-variable-font
                      :height hrs/current-variable-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/set-font-size ()
    "Change default, fixed-pitch, and variable-pitch font sizes to match respective variables."
    (set-face-attribute 'default nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'fixed-pitch nil
                        :height hrs/current-fixed-font-size)
    (set-face-attribute 'variable-pitch nil
                        :height hrs/current-variable-font-size))

  (defun hrs/reset-font-size ()
    "Revert font sizes back to defaults."
    (interactive)
    (setq hrs/current-fixed-font-size hrs/default-fixed-font-size)
    (setq hrs/current-variable-font-size hrs/default-variable-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font sizes by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-fixed-font-size
          (ceiling (* hrs/current-fixed-font-size hrs/font-change-increment)))
    (setq hrs/current-variable-font-size
          (ceiling (* hrs/current-variable-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font sizes by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-fixed-font-size
          (max 1
               (floor (/ hrs/current-fixed-font-size hrs/font-change-increment))))
    (setq hrs/current-variable-font-size
          (max 1
               (floor (/ hrs/current-variable-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+end_src

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Highlight uncommitted changes (Disabled)

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
;;  (use-package diff-hl
;;    :config
;;    (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
;;    (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+end_src
* Project management
** jira integration... let's see if this works well
#+begin_src emacs-lisp
    (setq jiralib-url "https://pubnativegmbh.atlassian.net")
    (setq org-jira-working-dir "~/documents/org/jira")
    (use-package org-jira)
#+end_src

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ag=

Install =ag= to provide search within projects (usually through
=projectile-ag=).

#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =avy=

Install =avy= to skip around the screen quickly.

#+begin_src emacs-lisp
  (use-package avy
    :bind*
    ("C-;" . avy-goto-char-2))
#+end_src

** =company=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

Use =M-/= for completion.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it doesn't
require any additional setup. I've bound its most useful command to =M-.=.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
;;    (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions)
  )
#+end_src

The =xref-find-definitions= function creates an =XREF= buffer of results if more
than one thing matches. That's inconvenient; I'd rather use Ivy to select among
them.

#+begin_src emacs-lisp
  (use-package ivy-xref
    :init
    (setq xref-show-definitions-function #'ivy-xref-show-defs))
#+end_src

** =flycheck=

I'd like to enable flycheck all kinds of places.

#+begin_src emacs-lisp
  (use-package let-alist)
  (use-package flycheck
    :init (global-flycheck-mode))
#+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
;;    (use-package evil-magit)
    (use-package with-editor)

    (setq magit-push-always-verify nil
          git-commit-summary-max-length 50)

;;    (add-hook 'with-editor-mode-hook 'evil-insert-state)
  )
#+end_src

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+begin_src emacs-lisp
  (use-package ghub)
  (use-package forge)
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . projectile-ag)

    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

;;    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)
;;    (evil-define-key 'motion rspec-compilation-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil))
#+end_src

** =restclient=

#+begin_src emacs-lisp
  (use-package restclient)
  (use-package company-restclient
    :config
    (add-to-list 'company-backends 'company-restclient))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree)
#+end_src
* Programming environments
** Playing with lsp-mode
#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (use-package lsp-mode                                  ;;
  ;;   :commands (lsp lsp-deferred)                         ;;
  ;;   :init                                                ;;
  ;;   (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l' ;;
  ;;   :config                                              ;;
  ;;   (lsp-enable-which-key-integration t))                ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+end_src


I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
    (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

** YAML

Ensure that we always use =fixed-pitch= fonts for YAML.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :config
    (add-hook 'yaml-mode-hook (lambda () (variable-pitch-mode 0))))
#+end_src

* Publishing and task management with Org-mode

Including =org-tempo= restores the =<s=-style easy-templates that were
deprecated in Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my
[[file:~/.dotfiles/email/.mailcap][mailcap]]. This clears the existing MIME mapping, parses my personal mailcap, and
tells Org to open those links with the mailcap-defined applications.

#+begin_src emacs-lisp
;;  (use-package org
;;    :ensure org-plus-contrib
;;    :config
;;    (require 'org-tempo)

;;    (add-hook 'org-mode-hook
;;              '(lambda ()
;;                 (setq mailcap-mime-data '())
;;                 (mailcap-parse-mailcap "~/.mailcap")
;;                 (setq org-file-apps
;;                       '((remote . emacs)
;;                         ("mobi" . "fbreader %s")
;;                         (system . mailcap)
;;                         ("md" . emacs)
;;                         ("org" . emacs)
;;                         (t . mailcap))))))
#+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+begin_src emacs-lisp
  (setq org-ellipsis "⤵")
#+end_src

This hides the slashes and stars that denote /emphasis/ and *bold* text.

#+begin_src emacs-lisp
  (setq org-hide-emphasis-markers t)
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of elisp:

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+end_src

Don't indent newly expanded blocks, even if they're under a heading.

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src

** Task management and agenda views

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+end_src

I store most of my personal tasks in my index and maintain a separate file for
work-related tasks, so I'd like to derive my agenda from those files. I've also
got some annual OKRs in =goals.org=.

I also keep a schedule in =events.org=. Plus some recurring events in,
reasonably, a =recurring-events.org= file. Those are (mostly) structured as
=org-habit= items so they can recur according to a schedule.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file
                               (org-file-path "events.org")
                               (org-file-path "habits.org")
                               (org-file-path "recurring-events.org")
                               (org-file-path "work.org")))
#+end_src

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+begin_src emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+end_src

Record the time that a todo was archived.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

*** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/documents/notes/blog-ideas.org=,
- Maintain a todo list in =~/documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file "~/documents/org/notes/blog-ideas.org")
           "* %?\n")

          ("c" "Contact"
           entry
           (file "~/documents/org/contacts.org")
           "* %(org-contacts-template-name)
  :PROPERTIES:
  :ADDRESS: %^{123 Fake St., City, ST 12345}
  :PHONE: %^{555-555-5555}
  :EMAIL: %(org-contacts-template-email)
  :NOTE: %^{note}
  :END:")

          ("d" "Delivery" entry
           (file+headline "~/documents/org/events.org" "Deliveries")
           "** %?\n   SCHEDULED: %t\n")

          ("e" "Email" entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n\n%a\n\n")

          ("f" "Finished book"
           table-line (file "~/documents/org/notes/books-read.org")
           "| %^{Title} | %^{Author} | %u |")

          ("j" "Work task"
           entry
           (file+headline "~/documents/org/work.org" "Tasks")
           "* TODO %?\n")

          ("k" "Kookaburra ingest"
           entry
           (file+headline "~/documents/org/kookaburra-ingest.org" "Queue")
           "* TODO %?\n")

          ("s" "Subscribe to an RSS feed"
           plain
           (file "~/documents/org/rss-feeds.org")
           "*** [[%^{Feed URL}][%^{Feed name}]]")

          ("t" "Todo"
           entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n")))
#+end_src

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step. (Disabled)

#+begin_src emacs-lisp
;;  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

*** Keybindings

Bind a few handy keys.

#+begin_src emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+end_src

Hit =C-c i= to quickly open up my todo list.

#+begin_src emacs-lisp
  (defun hrs/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'hrs/open-index-file)
#+end_src

Hit =M-n= to quickly open up a capture template for a new todo.

#+begin_src emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+end_src

Hit =C-c w= to quickly open up my work todo list.

#+begin_src emacs-lisp
  (defun hrs/open-work-file ()
    "Open the work TODO list."
    (interactive)
    (find-file (org-file-path "work.org"))
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c w") 'hrs/open-work-file)
#+end_src

** Exporting

Allow export to markdown and beamer (for presentations).

#+begin_src emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+end_src

Allow =babel= to evaluate Emacs lisp, java, Ruby, =ditaa=, Graphviz, or Gnuplot code.

#+begin_src emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (ditaa . t)
     (dot . t)
     (java . t)
     (gnuplot . t)))
#+end_src

Default behavior for ob-java differs from most babel languages in two ways:

ob-java defaults to scripting mode (:results output)
ob-java writes tempfiles to the current directory instead of the babel temporary directory

Let's make it more like most
#+begin_src emacs-lisp
  (setq org-babel-java-command "/usr/local/java/bin/java")
  (setq org-babel-java-compiler "/usr/local/java/bin/javac")
    ;;(nconc org-babel-default-header-args:java
    ;;       '((:dir . nil)
    ;;         (:results . value)))
#+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
    (setq org-confirm-babel-evaluate nil)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Associate the "dot" language with the =graphviz-dot= major mode.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+end_src

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

Include the =minted= package in all of my LaTeX exports.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+end_src

** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

* Knowledge Managment

** My brain isn't the best device to store information, let's play with org-brain

#+begin_src emacs-lisp
(use-package org-brain :ensure t
  :init
  (setq org-brain-path "~/documents/org/org-brain")
  ;; For Evil users
;;  (with-eval-after-load 'evil
;;    (evil-set-initial-state 'org-brain-visualize-mode 'emacs))
  :config
  (bind-key "C-c b" 'org-brain-prefix-map org-mode-map)
  (setq org-id-track-globally t)
  (setq org-id-locations-file "~/documents/org/.org-id-locations")
  (add-hook 'before-save-hook #'org-brain-ensure-ids-in-buffer)
  (push '("b" "Brain" plain (function org-brain-goto-end)
          "* %i%?" :empty-lines 1)
        org-capture-templates)
  (setq org-brain-visualize-default-choices 'all)
  (setq org-brain-title-max-length 12)
  (setq org-brain-include-file-entries nil
        org-brain-file-entries-use-title nil))

;; Allows you to edit entries directly from org-brain-visualize
(use-package polymode
  :config
  (add-hook 'org-brain-visualize-mode-hook #'org-brain-polymode))
#+end_src

** Or... maybe I want to use org-roam for my PKM System?
#+begin_src emacs-lisp
(use-package org-roam
      :ensure t
      :hook
      (after-init . org-roam-mode)
      :custom
      (org-roam-directory "~/documents/org/org-roam")
      :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))
              (("C-c n I" . org-roam-insert-immediate))))
#+end_src

*** Let's play around with dailies
#+begin_src emacs-lisp
  (setq org-roam-dailies-directory "~/documents/org/daily/")
  (setq org-roam-dailies-capture-templates
    '(("d" "default" entry
      #'org-roam-capture--get-point
      "* %?"
      :file-name "daily/%<%Y-%m-%d>"
      :head "#+title: %<%Y-%m-%d>\n\n")))
  (global-set-key (kbd "C-c d d") 'org-roam-dailies-find-today)
  (global-set-key (kbd "C-c d y") 'org-roam-dailies-find-yesterday)

#+end_src

* File management with =dired=

Hide dotfiles by default, but toggle their visibility with =.=.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

Open media with the appropriate programs.

#+begin_src emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("avi" . "mpv")
            ("cbr" . "comix")
            ("doc" . "abiword")
            ("docx" . "abiword")
            ("gif" . "ffplay")
            ("gnumeric" . "gnumeric")
            ("jpeg" . "s")
            ("jpg" . "s")
            ("mkv" . "mpv")
            ("mov" . "mpv")
            ("mp3" . "mpv")
            ("mp4" . "mpv")
            ("pdf" . "zathura")
            ("png" . "s")
            ("webm" . "mpv")
            ("xls" . "gnumeric")
            ("xlsx" . "gnumeric"))))
#+end_src

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

That said, I'd usually like to hide those extra details.
=dired-hide-details-mode= can be toggled with =(=.

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
#+end_src

Set up DWIM ("do what I mean") for =dired=. When I've got two =dired= windows
side-by-side, and I move or copy files in one window, this sets the default
location to the other window.

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

Kill buffers of files/directories that are deleted in =dired=.

#+begin_src emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+end_src

Always copy directories recursively instead of asking every time.

#+begin_src emacs-lisp
  (setq dired-recursive-copies 'always)
#+end_src

Ask before recursively /deleting/ a directory, though.

#+begin_src emacs-lisp
  (setq dired-recursive-deletes 'top)
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package async
    :config
    (dired-async-mode 1))
#+end_src

Use "j" and "k" to move around in =dired=.

#+begin_src emacs-lisp
;;  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
;;  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+end_src

I'm often browsing directories of photos and images, so this binds "v" to view a
slideshow of the current directory with =s= (a custom =feh= wrapper defined
elsewhere in this repo).

#+begin_src emacs-lisp
  (defun hrs/dired-slideshow ()
    (interactive)
    (start-process "dired-slideshow" nil "s" (dired-current-directory)))

;;  (evil-define-key 'normal dired-mode-map (kbd "v") 'hrs/dired-slideshow)
#+end_src

* Email
#+BEGIN_SRC emacs-lisp
      (use-package org-mime)

    (use-package mu4e
  ;;    :load-path "/snap/maildir-utils/current/share/emacs/site-lisp/mu4e"
      :load-path "/home/brian/Personal/projects/third-party/mu/mu4e"
      ;; usual configuration here...
    )
  ;;    (add-to-list 'load-path "/snap/maildir-utils/current/share/emacs/site-lisp/mu4e/")
  ;;    (require 'mu4e)

      ;; (setq mu4e-maildir (expand-file-name "/home/brian/Maildir"))

      ; get mail
      (setq mu4e-get-mail-command "mbsync -c ~/.mbsyncrc -a"
        ;; mu4e-html2text-command "w3m -T text/html" ;;using the default mu4e-shr2text
        mu4e-update-interval 180
        mu4e-headers-auto-update t
        mu4e-compose-signature-auto-include nil
        mu4e-compose-format-flowed t)

      ;; to view selected message in the browser, no signin, just html mail
      (add-to-list 'mu4e-view-actions
        '("ViewInBrowser" . mu4e-action-view-in-browser) t)

      ;; enable inline images
      (setq mu4e-view-show-images t)
      ;; use imagemagick, if available
      (when (fboundp 'imagemagick-register-types)
        (imagemagick-register-types))

      ;; every new email composition gets its own frame!
      (setq mu4e-compose-in-new-frame t)

      ;; don't save message to Sent Messages, IMAP takes care of this
      (setq mu4e-sent-messages-behavior 'delete)

      (add-hook 'mu4e-view-mode-hook #'visual-line-mode)

      ;; <tab> to navigate to links, <RET> to open them in browser
      (add-hook 'mu4e-view-mode-hook
        (lambda()
      ;; try to emulate some of the eww key-bindings
      (local-set-key (kbd "<RET>") 'mu4e~view-browse-url-from-binding)
      (local-set-key (kbd "<tab>") 'shr-next-link)
      (local-set-key (kbd "<backtab>") 'shr-previous-link)))

      ;; from https://www.reddit.com/r/emacs/comments/bfsck6/mu4e_for_dummies/elgoumx
      (add-hook 'mu4e-headers-mode-hook
            (defun my/mu4e-change-headers ()
        (interactive)
        (setq mu4e-headers-fields
              `((:human-date . 25) ;; alternatively, use :date
          (:flags . 6)
          (:from . 22)
          (:thread-subject . ,(- (window-body-width) 70)) ;; alternatively, use :subject
          (:size . 7)))))

      ;; if you use date instead of human-date in the above, use this setting
      ;; give me ISO(ish) format date-time stamps in the header list
      ;(setq mu4e-headers-date-format "%Y-%m-%d %H:%M")

      ;; spell check
      (add-hook 'mu4e-compose-mode-hook
          (defun my-do-compose-stuff ()
             "My settings for message composition."
             (visual-line-mode)
             (org-mu4e-compose-org-mode)
                 (use-hard-newlines -1)
             (flyspell-mode)))

      (require 'smtpmail)

      ;;rename files when moving
      ;;NEEDED FOR MBSYNC
      (setq mu4e-change-filenames-when-moving t)

      ;;set up queue for offline email
      ;;use mu mkdir  ~/Maildir/acc/queue to set up first
      (setq smtpmail-queue-mail nil)  ;; start in normal mode

      ;;from the info manual
      (setq mu4e-attachment-dir  "~/Downloads")

      (setq message-kill-buffer-on-exit t)
      (setq mu4e-compose-dont-reply-to-self t)

      (require 'org-mu4e)

      ;; convert org mode to HTML automatically
      (setq org-mu4e-convert-to-html t)

      ;;from vxlabs config
      ;; show full addresses in view message (instead of just names)
      ;; toggle per name with M-RET
      (setq mu4e-view-show-addresses 't)

      ;; don't ask when quitting
      (setq mu4e-confirm-quit nil)

      ;; from: https://www.reddit.com/r/emacs/comments/6ul9rz/email_html_rendering_mu4e_with_html2text_how_to/
      (require 'mu4e-contrib)

      (setq mu4e-html2text-command 'mu4e-shr2text)

      (setq shr-color-visible-luminance-min 80)

      (setq shr-color-visible-distance-min 5)

      ;; mu4e-context
      (setq mu4e-context-policy 'pick-first)
      (setq mu4e-compose-context-policy 'always-ask)
      (setq mu4e-contexts
        (list
         (make-mu4e-context
          :name "verve" ;;for brian-verve-gmail
          :enter-func (lambda () (mu4e-message "Entering context verve"))
          :leave-func (lambda () (mu4e-message "Leaving context verve"))
          :match-func (lambda (msg)
                        (when msg
                      (mu4e-message-contact-field-matches
                       msg '(:from :to :cc :bcc) "brian@verve.com")))
          :vars '((user-mail-address . "brian@verve.com")
                  (user-full-name . "Brian Collison")
                  (mu4e-sent-folder . "/brian-verve-gmail/[brian-verve].sent")
                  (mu4e-drafts-folder . "/brian-verve-gmail/[brian-verve].drafts")
                  (mu4e-trash-folder . "/brian-verve-gmail/[brian-verve].trash")
                  (mu4e-refile-folder . "/brian-verve-gmail/[brian-verve].All Mail")
                  (mu4e-compose-signature . (concat "Formal Signature\n" "Emacs 25, org-mode 9, mu4e 1.0\n"))
                  (mu4e-compose-format-flowed . t)
                  (smtpmail-queue-dir . "/home/brian/Maildir/brian-verve-gmail/queue/cur")
                  (message-send-mail-function . smtpmail-send-it)
                  (smtpmail-smtp-user . "brian@verve.com")
                  (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
                  (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
                  (smtpmail-default-smtp-server . "smtp.gmail.com")
                  (smtpmail-smtp-server . "smtp.gmail.com")
                  (smtpmail-smtp-service . 587)
                  (smtpmail-debug-info . t)
                  (smtpmail-debug-verbose . t)
                  (mu4e-maildir-shortcuts . ( ("/brian-verve-gmail/INBOX"            . ?i)
                                              ("/brian-verve-gmail/[brian-verve].sent" . ?s)
                                              ("/brian-verve-gmail/[brian-verve].trash"       . ?t)
                                              ("/brian-verve-gmail/[brian-verve].All Mail"       . ?l)
                                              ("/brian-verve-gmail/[brian-verve].actionable"  . ?a)
                                              ("/brian-verve-gmail/[brian-verve].wait"   . ?w)
                                              ("/brian-verve-gmail/[brian-verve].reference"   . ?r)
                                              ("/brian-verve-gmail/[brian-verve].inflight"   . ?f)
                                              ("/brian-verve-gmail/[brian-verve].drafts"    . ?d)
                                              ))))

         (make-mu4e-context
          :name "personal" ;;for bcollison-gmail
          :enter-func (lambda () (mu4e-message "Entering context personal"))
          :leave-func (lambda () (mu4e-message "Leaving context personal"))
          :match-func (lambda (msg)
            (when msg
          (mu4e-message-contact-field-matches
           msg '(:from :to :cc :bcc) "bcollison@gmail.com")))
          :vars '((user-mail-address . "bcollison@gmail.com")
            (user-full-name . "Brian Collison")
            (mu4e-sent-folder . "/bcollison-gmail/[bcollison].sent")
            (mu4e-drafts-folder . "/bcollison-gmail/[bcollison].drafts")
            (mu4e-trash-folder . "/bcollison-gmail/[bcollison].trash")
            (mu4e-refile-folder . "/bcollison-gmail/[bcollison].All Mail")
            (mu4e-compose-signature . (concat "Formal Signature\n" "Emacs 25, org-mode 9, mu4e 1.0\n"))
            (mu4e-compose-format-flowed . t)
            (smtpmail-queue-dir . "/home/brian/Maildir/bcollison-gmail/queue/cur")
            (message-send-mail-function . smtpmail-send-it)
            (smtpmail-smtp-user . "bcollison")
            (smtpmail-starttls-credentials . (("smtp.gmail.com" 587 nil nil)))
            (smtpmail-auth-credentials . (expand-file-name "~/.authinfo.gpg"))
            (smtpmail-default-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-server . "smtp.gmail.com")
            (smtpmail-smtp-service . 587)
            (smtpmail-debug-info . t)
            (smtpmail-debug-verbose . t)
            (mu4e-maildir-shortcuts . ( ("/bcollison-gmail/INBOX"            . ?i)
                ("/bcollison-gmail/[bcollison].sent" . ?s)
                ("/bcollison-gmail/[bcollison].trash"       . ?t)
                ("/bcollison-gmail/[bcollison].All Mail"       . ?l)
                ("/bcollison-gmail/[bcollison].actionable"  . ?a)
                ("/bcollison-gmail/[bcollison].wait"   . ?w)
                ("/bcollison-gmail/[bcollison].reference"   . ?r)
                ("/bcollison-gmail/[bcollison].inflight"   . ?f)
                ("/bcollison-gmail/[bcollison].drafts"    . ?d)
                ))))
         )
      )

  (global-set-key (kbd "C-\"") 'mu4e)

#+END_SRC

* Calendaring

** Pull calendar data
#+begin_src emacs-lisp
#+end_src

** Display a nice calendar
#+begin_src emacs-lisp
(use-package calfw)
(use-package calfw-org)
#+end_src
* Reading things

** RSS with =elfeed=

Install elfeed and load up my feeds.

#+begin_src emacs-lisp
  (use-package elfeed
    :config
    (elfeed-set-max-connections 32)
    (setq elfeed-search-filter "@1-week-ago +unread "))

  (use-package elfeed-org
    :config
    (progn
      (elfeed-org)
      (setq rmh-elfeed-org-files (list "~/documents/org/rss-feeds.org"))))
#+end_src

Sort RSS feeds first by tag (=comics= come before =haskell=, for example), then
by name of the feed, and finally by publication date.

#+begin_src emacs-lisp
  (defun hrs/custom-elfeed-sort (a b)
    (let* ((a-tags (format "%s" (elfeed-entry-tags a)))
           (b-tags (format "%s" (elfeed-entry-tags b)))
           (a-title (elfeed-feed-title (elfeed-entry-feed a)))
           (b-title (elfeed-feed-title (elfeed-entry-feed b))))
      (if (string= a-tags b-tags)
          (if (string= a-title b-title)
              (< (elfeed-entry-date b) (elfeed-entry-date a))
            (string< b-title a-title))
        (string< a-tags b-tags))))

  (setf elfeed-search-sort-function #'hrs/custom-elfeed-sort)
#+end_src

Open =elfeed= with =C-c r=:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'elfeed)
#+end_src

Use =o= to browse the entry in a Web browser and open links with =C-c C-o=.

#+begin_src emacs-lisp
;;  (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode)
;;  (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)

;;  (evil-add-hjkl-bindings elfeed-search-mode-map)
;;  (evil-add-hjkl-bindings elfeed-show-mode-map)

;;  (define-key elfeed-show-mode-map "o" 'elfeed-show-visit)
;;  (define-key elfeed-search-mode-map "o" 'elfeed-search-browse-url)

;;  (define-key elfeed-show-mode-map (kbd "C-c C-o") 'org-open-at-point)
#+end_src

Some external integrations need access to the current entry at point:

#+begin_src emacs-lisp
  (defun hrs/elfeed-current-entry ()
    (cond ((eq major-mode 'elfeed-show-mode)
           elfeed-show-entry)
          ((eq major-mode 'elfeed-search-mode)
           (elfeed-search-selected t))))
#+end_src
* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
  (defun hrs/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+end_src

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+end_src

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
;;  (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+end_src

** Look for executables in =/usr/local/bin=

#+begin_src emacs-lisp
  (hrs/append-to-path "/usr/local/bin")
  (hrs/append-to-path "/usr/local/java/bin")
#+end_src

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

** Configure =yasnippet=

#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+begin_src emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+end_src

I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+begin_src emacs-lisp
  (setq yas-indent-line 'auto)
#+end_src

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
(use-package ivy-rich
  :init
  (ivy-rich-mode 1))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+begin_src emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+end_src

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+begin_src emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+end_src

** Use projectile everywhere

#+begin_src emacs-lisp
  (projectile-global-mode)
#+end_src

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+begin_src emacs-lisp
  (use-package engine-mode)
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s")

  (engine-mode t)
#+end_src

** Show my available key-bindings
#+begin_src emacs-lisp
  (use-package free-keys)
#+end_src

* Set custom keybindings

Just a few handy functions.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
#+end_src

Remap when working in terminal Emacs.

#+begin_src emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+end_src
* Extra
** sublima Sublime-like Scratch files
I use sublime as a temporary place to do text modification/searching. I like how
sublime auto-saves things. Someone else enjoyed that too. Here is his attempt
at recreating that
#+begin_src emacs-lisp
  (load-file "/home/brian/Personal/projects/emacs-libraries/sublima/sublima.el")
(global-set-key (kbd "<f7>") 'sublima-scratch)
(global-set-key (kbd "<f8>") 'previous-buffer)
(global-set-key (kbd "<f9>") 'next-buffer)
#+end_src
